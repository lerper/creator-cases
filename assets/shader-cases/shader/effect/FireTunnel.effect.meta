{
  "ver": "1.0.25",
  "uuid": "ad02a119-b7db-419e-8058-939efed4cbcd",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n#endif\nuniform vec4 cc_time;\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform vec2 resolution;\nvec3 iResolution = vec3(resolution, 1.0);\nfloat iGlobalTime = cc_time.x -60.;\nfloat hash(in float n){ return fract(sin(n)*43758.5453); }\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\nvec3 path(in float t){return vec3(sin(t*.3),sin(t*0.25),0.)*0.3;}\nmat2 m2 = mat2( 0.970,  0.242, -0.242,  0.970 );\nfloat triNoise3d(in vec3 p)\n{\n  float z=1.5;\n  float rz = 0.;\n  vec3 bp = p;\n  for (float i=0.; i<=3.; i++ )\n  {\n        vec3 dg = tri3(bp*2.)*1.;\n        p += (dg+iGlobalTime*2.*0.25);\n        bp *= 1.8;\n    z *= 1.5;\n    p *= 1.1;\n        p.xz*= m2;\n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n  }\n  return rz;\n}\nfloat map(vec3 p)\n{\n    p -= path(p.z);\n    float d = 1.-length(p.xy);\n    return d;\n}\nfloat march(in vec3 ro, in vec3 rd)\n{\n  float precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    float id = 0.;;\n    for( int i=0; i<50; i++ )\n    {\n        if( abs(h)<precis || d>25. ) break;\n        d += h;\n      float res = map(ro+rd*d);\n        h = res;\n    }\n  return d;\n}\nfloat mapVol(vec3 p)\n{\n    p -= path(p.z);\n    float d = 1.-length(p.xy);\n    d -= triNoise3d(p*0.15)*1.2;\n    return d*0.55;\n}\nvec4 marchVol( in vec3 ro, in vec3 rd )\n{\n  vec4 rz = vec4(0);\n  float t = 0.3;\n  for(int i=0; i<20; i++)\n  {\n    if(rz.a > 0.99)break;\n    vec3 pos = ro + t*rd;\n        float r = mapVol( pos );\n        float gr =  clamp((r - mapVol(pos+vec3(.0,.1,.5)))/.5, 0., 1. );\n        vec3 lg = vec3(0.7,0.5,.1)*1.2 + 3.*vec3(1)*gr;\n        vec4 col = vec4(lg,r+0.55);\n    col.a *= .2;\n    col.rgb *= col.a;\n    rz = rz + col*(1. - rz.a);\n    t += 0.05;\n  }\n  rz.b += rz.w*0.2;\n    rz.rg *= mm2(-rd.z*0.09);\n    rz.rb *= mm2(-rd.z*0.13);\n  return clamp(rz, 0.0, 1.0);\n}\nvoid main () {\n  vec2 p = gl_FragCoord.xy/iResolution.xy-0.5;\np.x*=iResolution.x/iResolution.y;\np += vec2(hash(iGlobalTime*2.),hash(iGlobalTime*2.+1.))*0.008;\n  float dz = sin(iGlobalTime*2.*.3)*8.+1.;\n  vec3 ro = path(iGlobalTime*2.*5.+dz)*.7+vec3(0,0,iGlobalTime*2.*5.);\n  vec3 tgt = vec3(0,0,iGlobalTime*2.*5.+10.);\n  vec3 eye = normalize( tgt - ro);\n  vec3 rgt = normalize(cross( vec3(0.0,1.0,0.0), eye ));\n  vec3 up = normalize(cross(eye,rgt));\n  vec3 rd = normalize( p.x*rgt + p.y*up + .75*eye );\nfloat rz = march(ro,rd);\n  vec3 pos = ro+rz*rd;\n  vec4 col = marchVol(pos,rd);\n  vec3 ligt = normalize( vec3(-.0, 0., -1.) );\n  vec2 spi = vec2(sin(iGlobalTime*2.),cos(iGlobalTime*2.))*1.;\n  float flick = clamp(1.-abs(((pos.z-iGlobalTime*2.*5.)*0.3+mod(iGlobalTime*2.*5.,30.))-15.),0.,1.)*clamp(dot(pos.xy,spi),0.,1.)*1.7;\n  col.rgb += flick*(step(mod(iGlobalTime*2.,2.5),0.2))*.4;\n  col.rgb += flick*(step(mod(iGlobalTime*2.*1.5,3.2),0.2))*.4;\n  col.rgb = mix(col.rgb*col.rgb,col.rgb*1.2,(1.-col.w)*step(tri(iGlobalTime*2.*.25),0.1)*smoothstep(0.5,1.,2.*tri(iGlobalTime*2.)));\ngl_FragColor = vec4( col.rgb, 1.0 );\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform Params {\n  vec2 resolution;\n};\nvec3 iResolution = vec3(resolution, 1.0);\nfloat iGlobalTime = cc_time.x -60.;\nfloat hash(in float n){ return fract(sin(n)*43758.5453); }\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\nvec3 path(in float t){return vec3(sin(t*.3),sin(t*0.25),0.)*0.3;}\nmat2 m2 = mat2( 0.970,  0.242, -0.242,  0.970 );\nfloat triNoise3d(in vec3 p)\n{\n  float z=1.5;\n  float rz = 0.;\n  vec3 bp = p;\n  for (float i=0.; i<=3.; i++ )\n  {\n        vec3 dg = tri3(bp*2.)*1.;\n        p += (dg+iGlobalTime*2.*0.25);\n        bp *= 1.8;\n    z *= 1.5;\n    p *= 1.1;\n        p.xz*= m2;\n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n  }\n  return rz;\n}\nfloat map(vec3 p)\n{\n    p -= path(p.z);\n    float d = 1.-length(p.xy);\n    return d;\n}\nfloat march(in vec3 ro, in vec3 rd)\n{\n  float precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    float id = 0.;;\n    for( int i=0; i<50; i++ )\n    {\n        if( abs(h)<precis || d>25. ) break;\n        d += h;\n      float res = map(ro+rd*d);\n        h = res;\n    }\n  return d;\n}\nfloat mapVol(vec3 p)\n{\n    p -= path(p.z);\n    float d = 1.-length(p.xy);\n    d -= triNoise3d(p*0.15)*1.2;\n    return d*0.55;\n}\nvec4 marchVol( in vec3 ro, in vec3 rd )\n{\n  vec4 rz = vec4(0);\n  float t = 0.3;\n  for(int i=0; i<20; i++)\n  {\n    if(rz.a > 0.99)break;\n    vec3 pos = ro + t*rd;\n        float r = mapVol( pos );\n        float gr =  clamp((r - mapVol(pos+vec3(.0,.1,.5)))/.5, 0., 1. );\n        vec3 lg = vec3(0.7,0.5,.1)*1.2 + 3.*vec3(1)*gr;\n        vec4 col = vec4(lg,r+0.55);\n    col.a *= .2;\n    col.rgb *= col.a;\n    rz = rz + col*(1. - rz.a);\n    t += 0.05;\n  }\n  rz.b += rz.w*0.2;\n    rz.rg *= mm2(-rd.z*0.09);\n    rz.rb *= mm2(-rd.z*0.13);\n  return clamp(rz, 0.0, 1.0);\n}\nvoid main () {\n  vec2 p = gl_FragCoord.xy/iResolution.xy-0.5;\np.x*=iResolution.x/iResolution.y;\np += vec2(hash(iGlobalTime*2.),hash(iGlobalTime*2.+1.))*0.008;\n  float dz = sin(iGlobalTime*2.*.3)*8.+1.;\n  vec3 ro = path(iGlobalTime*2.*5.+dz)*.7+vec3(0,0,iGlobalTime*2.*5.);\n  vec3 tgt = vec3(0,0,iGlobalTime*2.*5.+10.);\n  vec3 eye = normalize( tgt - ro);\n  vec3 rgt = normalize(cross( vec3(0.0,1.0,0.0), eye ));\n  vec3 up = normalize(cross(eye,rgt));\n  vec3 rd = normalize( p.x*rgt + p.y*up + .75*eye );\nfloat rz = march(ro,rd);\n  vec3 pos = ro+rz*rd;\n  vec4 col = marchVol(pos,rd);\n  vec3 ligt = normalize( vec3(-.0, 0., -1.) );\n  vec2 spi = vec2(sin(iGlobalTime*2.),cos(iGlobalTime*2.))*1.;\n  float flick = clamp(1.-abs(((pos.z-iGlobalTime*2.*5.)*0.3+mod(iGlobalTime*2.*5.,30.))-15.),0.,1.)*clamp(dot(pos.xy,spi),0.,1.)*1.7;\n  col.rgb += flick*(step(mod(iGlobalTime*2.,2.5),0.2))*.4;\n  col.rgb += flick*(step(mod(iGlobalTime*2.*1.5,3.2),0.2))*.4;\n  col.rgb = mix(col.rgb*col.rgb,col.rgb*1.2,(1.-col.w)*step(tri(iGlobalTime*2.*.25),0.1)*smoothstep(0.5,1.,2.*tri(iGlobalTime*2.)));\ngl_FragColor = vec4( col.rgb, 1.0 );\n}"
      }
    }
  ],
  "subMetas": {}
}